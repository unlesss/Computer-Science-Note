	是一种架构设计方法论，而非架构。关注于创建与业务领域紧密相关的软件模型，以确保软件能够准确地解决实际问题。

# 核心理念

## 领域模型
	即要解决的业务问题域，反映了业务专家的语言和决策
### 领域（Domain Model）
	指具体业务领域的知识、业务逻辑、数据以及业务规则的集合。由一系列子领域组成，每个子领域代表业务中的一个特定部分。
#### 领域特性
1. 业务中心：需求和业务为中心
2. 模型驱动：业务知识抽象，通过其他基本概念来表达
3. 语言一致性：ubiquitous
4. 边界清晰：划分
#### 领域的用途
1. 业务逻辑的封装：业务规则和数据操作集中管理
2. 沟通工具
3. 软件设计基础：指导软件架构

#### 实现手段

1. 实体（Entity）：具有唯一标识的领域对象，代表业务中的实体。
2. 值对象（Value Object）：描述领域中的一些特性或概念，没有唯一标识，通常是不可变的。
3. 聚合（Aggregate）：一组相关的实体和值对象的集合，它们一起构成一个数据和业务规则的单元。
4. 领域服务（Domain Service）：在领域模型中执行特定业务逻辑的无状态服务，通常操作多个实体或聚合。
5. 领域事件（Domain Event）：表示领域中发生的重要业务事件，用于解耦系统的不同部分。
6. 仓储（Repository）：提供对聚合根的持久化操作，如保存和检索，通常与数据库交互。
7. 领域适配器（Domain Adapter）：领域适配器是适配器模式在DDD中的应用，它的目的是使得领域模型能够与外部系统或技术细节进行交互，而不会受到污染。
8. 工厂（Factory）：用于创建复杂的聚合或实体，封装创建逻辑。如 OpenAi项目、Lottery 项目都运用了工厂，也包括如 chatglm-sdk-java 的开发，就是会话模型结构用工厂对外提供服务。

##### 聚合对象
	相关对象的集合
聚合内：事务一致性
聚合外：最终一致性

特性：
1. 一致性边界（内部对象变化一致），
2. 根实体（聚合的入口点，全局唯一的标识，对象通过根实体与聚合交互），
3. 事务边界（变更操作是原子性的）

实现手段：
1. 定义聚合根
2. 限制访问路径
3. 设计事务策略
4. 封装业务规则
5. 持久化

##### 实体
	具有唯一标识的领域对象。

唯一标识 + 状态属性 + 行为动作（功能），代表了具有唯一标识的领域对象

特性：
1. 唯一标识：ID，复合key，自然key
2. 领域标识：业务领域标识
3. 委派标识：ORM框架自动生成，不直接来源于业务领域
实现方法：
1. 定义
2. 标识
3. orm框架
4. 领域服务
5. 领域事件

##### 值对象
	封装和表示领域中的概念，其特点是它们描述了领域中的某些属性或度量，但不具有唯一标识。
	值对象 = 值 + 对象，用于描述对象属性的值，表示具体固定不变的属性值信息。

特性：
1. 不可变性：被创建后状态不变，保证领域模型的一致性和线程安全性。
2. 等价性：等价性不是基于身份或引用，而是基于对象的属性值。
3. 替换性：值对象是不可变的，任何需要改变值对象的操作都会导致创建一个新的值对象实例，而不是修改现有的实例。
4. 状态描述：描述事物的状态，而不是事物的唯一身份。
5. 可复用性：不同的领域实体或其他值对象中重复使用。

## 统一语言
	开发团队与业务专家共同使用的语言

## 限界上下文
	明确界定的系统边界，在这个边界内部有一套统一的模型和语言。不同的限界上下文之间可能有不同的模型，它们通过上下文映射（Context Mapping）来进行交互和集成。

## 聚合
	一组相关对象的集合，它们被视为数据修改的单元。每个聚合都有一个聚合根，它是外部对象与聚合内部对象交互的唯一入口。

## 领域服务
	领域中的一些操作或业务逻辑。

## 应用服务
	软件的一部分，它们协调领域对象来执行任务。它们负责应用程序的工作流程，但不包含业务规则或知识。

## 基础设施
	领域模型提供持久化机制（如数据库）、消息传递、应用程序的配置等技术组件。

## 领域事件
	领域事件是领域中发生的有意义的业务事件，它们可以触发其他子系统的反应或流程。


# 软件设计方法

	指一系列用于指导软件开发过程的原则、概念和实践。这些方法通常包括范式、模型、框架和方法论。

## 范式
结构化编程
函数式编程
事件驱动编程
## 模型
UML
ER
状态机模型
## 框架

## 方法论
敏捷开发
Scrum
瀑布模型

## 主要活动

1. 建模
2. 测试
3. 工程
4. 开发
5. 部署
6. 维护















### 子域的分类
	核心域、通用域和支撑域。

1. 核心域：决定产品和公司核心竞争力的子域，没有太多个性化的诉求
2. 通用域：同时被多个子域使用的通用功能子域是通用域
3. 支撑域：是必需的，但既不包含决定产品和公司核心竞争力的功能，也不包含通用功能的子域

	通用域则是你需要用到的通用系统，比如认证、权限等等，这类应用很容易买到，没有企业特点限制，不需要做太多的定制化。
	支撑域则具有企业特性，但不具有通用性，例如数据代码类的数据字典等系统。

## 限界上下文
	通过领域的限界上下文，我们就可以在统一的领域边界内用统一的语言进行交流，可以理解为语义环境。

**理论上限界上下文就是微服务的边界。我们将限界上下文内的领域模型映射到微服务，就完成了从问题域到软件的解决方案。**


## 贫血模型和充血模型

### 贫血模型

贫血模型具有一堆属性和set get方法，存在的问题就是通过pojo这个对象上看不出业务有哪些逻辑，一个pojo可能被多个模块调用，只能去上层各种各样的service来调用，这样以后当梳理这个实体有什么业务，只能一层一层去搜service，也就是贫血失忆症，**不够面向对象**

### 充血模型

user用户有改密码，改手机号，修改登录失败次数等操作，都内聚在这个user实体中，每个实体的业务都是清晰的，就是充血模型，充血模型的内存计算会多一些，内聚核心业务逻辑处理。

```java
@NoArgsConstructor
@Getter
public class User extends Aggregate<Long, User> {

    private String userName;

    private String realName;

    private String phone;

    private String password;

    private Date lockEndTime;

    private Integer failNumber;

    private List<Role> roles;

    private Department department;

    private UserStatus userStatus;

    private Address address;

    public User(String userName, String phone, String password) {
        saveUserName(userName);
        savePhone(phone);
        savePassword(password);
    }
    private void saveUserName(String userName) {...}

    private void savePhone(String phone) {...}

    private void savePassword(String password) {...}

    public void saveAddress(String province,String city,String region){...}

    public void saveRole(List<Role> roleList) {...}
}
```

不只是有贫血模型中setter getter方法，还有其他的一些业务方法，这才是面向对象的本质，**通过user实体就能看出有哪些业务存在**。

## 实体值和对象
	领域模型中的领域对象。实体和值对象是组成领域模型的基础单元。



