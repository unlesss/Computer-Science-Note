# 2.3 HotSpot 虚拟机对象

## 2.3.3 对象的访问定位
	Java程序会通过栈上的reference数据来操作堆上的具体对象
	虚拟机定义对象访问方式

### 句柄访问方式
	Java堆中将可能会划分出一块内存来作为句柄池

reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息
![[截屏2023-07-27 10.38.17.png|650]]
#### 优势
reference中存储的是稳定句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而 reference本身不需要被修改。

### 直接指针方式
	使用直接指针访问的话，Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息

reference中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问的开销
![[截屏2023-07-27 10.42.58.png|650]]
#### 优势
直接指针来访问最大的好处就是速度更快，它节省了一次指针定位的时间开销，由于对象访问在Java中非常频繁，因此这类开销积少成多也是一项极为可观的执行成本。

## 2.4 OutOfMemoryError 异常

### 2.4.1 Java堆溢出
	Java堆用于储存对象实例，我们只要不断地创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么随着对象数量的增加，总容量触及最大堆的容量限制后就会产生内存溢出异常。

限制Java堆的大小为20MB，不可扩展（将堆的最小值-Xms参数与最大值-Xmx参数设置为一样即可避免堆自动扩展），通过参数 -XX：+**HeapDumpOnOutOf-MemoryError** 可以让虚拟机在出现内存溢出异常的时候Dump出当前的内存堆转储快照以便进行事后分析。

##### 处理内存区域异常

**第一步** 
 1. 应确认内存中导致OOM的对象是否是必 要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）。
**第二步** 
1. 如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链，找到泄漏对象是通过怎样的引用路径、与哪些GC Roots相关联，才导致垃圾收集器无法回收它们，根据泄漏对象的类型信息 以及它到GC Roots引用链的信息，一般可以比较准确地定位到这些对象创建的位置，进而找出产生内存泄漏的代码的具体位置。
2. 如果不是内存泄漏，换句话说就是内存中的对象确实都是必须存活的，那就应当检查Java虚拟机的堆参数（-Xmx与-Xms）设置，与机器的内存对比，看看是否还有向上调整的空间。再从代码上检查是否存在某些对象生命周期过长、持有状态时间过长、存储结构设计不合理等情况，尽量减少程序运行期的内存消耗。

### 2.4.2 虚拟机栈和本地方法栈溢出
	由于HotSpot虚拟机中并不区分虚拟机栈和本地方法栈，因此对于HotSpot来说，-Xoss参数（设置本地方法栈大小）虽然存在，但实际上是没有任何效果的，栈容量只能由-Xss参数来设定。
	HotSpot虚拟机不支持栈的动态扩展

**关于虚拟机栈和本地方法栈，在《Java虚拟机规范》中描述了两种异常：**
1. 如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。
2. 如果虚拟机的栈内存允许动态扩展，当扩展栈容量无法申请到足够的内存时，将抛出 OutOfMemoryError异常。

**除非在创建线程申请内存时就因无法获得足够内存而出现 OutOfMemoryError异常，否则在线程运行时是不会因为扩展而导致内存溢出的，只会因为栈容量无法 容纳新的栈帧而导致StackOverflowError异常。**

#### 验证方法

1. 使用-Xss参数减少栈内存容量。 ——结果：抛出StackOverflowError异常，异常出现时输出的堆栈深度相应缩小。 
![[截屏2023-07-27 11.15.02.png|650]]
![[截屏2023-07-27 11.15.30.png|650]]
2. 定义了大量的本地变量，增大此方法帧中本地变量表的长度。 ——结果：抛出StackOverflowError异常，异常出现时输出的堆栈深度相应缩小。

#### 分析
	无论是由于栈帧太大还是虚拟机栈容量太小，当新的栈帧内存无法分配的时候， HotSpot虚拟机抛出的都是StackOverflowError异常。

相同的代码在Classic虚拟机中成功产生了OutOfMemoryError而不是StackOver-flowError异常。如果测试时不限于单线程，通过不断建立线程的方式，在HotSpot上也是可以产生内存溢出异常的

**这样产生的内存溢出异常和栈空间是否足够并不存在任何直接的关系，主要取决于操作系统本身的内存使用状态。甚至可以说，在这种情况下，给每个线程的栈分配的内存越大，反而越容易产生内存溢出异常。**


