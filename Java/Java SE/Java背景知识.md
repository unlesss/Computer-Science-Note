# 基础和常识
	Java基础的简单概念

## Java语言的特点

1. 简单/动态性 **没有头文件，指针，结构，联合运算符重载，虚基数** *库中添加新方法和实例变量，不影响客户端*
2. 面向对象 **继承，多态，封装**
3. 平台无关性/可移植性 **生成字节码** *基本数据类型大小和有关运算固定，字符串以标准unicode格式存储的*
4. 多线程 
5. 可靠性 **异常处理，垃圾回收**
6. 安全性/健壮性 **Java能够检测出其他语言运行时检测出的错误，早期问题检测，后期动态监测，指针模型可以消除重写内存和损坏数据的可能性** *运行时堆栈溢出，破坏进程空间之外的内存，未经授权读写文件*
7. 高效性 **通过 Just In Time 编译器等技术的优化，Java 语言的运行效率还是非常不错的**
8. 支持网络编程，分布式
9. 编程和解释并存 **Java字节码在在任何移植了解释器的机器上执行**
10. 高性能 **字节码可以(在运行时刻)动态地翻译成对应运行这个应用的特定 CPU 的机
器码。**

## JVM & JDK & JRE

### JVM 
	运行Java字节码的虚拟机

针对不同系统有特定实现，目的是使用相同字节码，得出同样的结果
**JVM不仅有一种**，满足规范即可
![[截屏2023-08-04 10.29.08.png|525]]

### JDK & JRE
	JDK9 开始不区分，转为模块系统，JDK 被重新组织成 94 个模块。Java 应用可以通过新增的 jlink 工具，创建出只包含所依赖的 JDK 模块的自定义运行时镜像。这样可以极大的减少 Java 运行时环境的大小。
		可以使用jlink创建runtime，

#### JDK

是功能齐全的Java SDK，包含JRE和其他工具

其他工具：*javac apt jar jdb javadoc*

#### JRE

是Java运行环境，是运行已编译程序所需内容的集合，**包含JVM和Java核心类库**

## 字节码
	面向虚拟机

字节码是由**十六进制**组成的，而 JVM以**两个十六进制为一组**，即以字节为单位进行读取。
符合字节码规范的文件都能在JVM上运行，其他语言也可以对Java进行扩展

.java -> javac编译 -> .class -> 机器码

JIT ---*HotSpot 采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是 JIT 所需要编译的部分。JVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快*



### 字节码结构
![[截屏2023-08-04 10.09.03.png|750]]

1. **魔数** 每个字节码文件的头 4 个字节称为 ，它的唯一作用是**确定这个文件是否为一个能被虚拟机接受的 Class 文件**。很多文件存储标准中都使用魔数来进行身份识别，譬如图片格式，如 gif 或者 jpg 等在文件中都存有魔数。使用魔数而不是扩展名来进行识别主要是基于安全方面的考虑，因为文件扩展名可以随意改动。魔数的固定值为: 0xCAFEBABE，魔数放在文件头，JVM 可以根据文件的开头来判断这个文件是否可能是一个字节码文件，如果是，才会进行之后的操作。
2. **版本号** 为魔数之后的 4 个字节，前两个字节表示次版本号（Minor Version），后两个字节表示主版本号（Major Version）。
3. **常量池**（Constant Pool） 紧接着主版本号之后的字节是常量池入口。常量池中存储两种类型常量: 字面量和符号运用。字面量为代码中声明为 final 的常量值，符号引用如类和接口的全局限定名、字段的名称和描述符、方法的名称和描述符。常量池整体上分为两部分: 常量池计数器和常量池数据区
	*常量池计数器*（constant_pool_count）: 由于常量池的数量不固定，所以需要先放置两个字节来表示常量池容量计数值
	![[截屏2023-08-04 10.13.38.png|700]]、
	*常量池数据区* 由（constant_pool_count - 1）个 cp_info 结构组成，一个 cp_info 的结构对应一个常量。在字节码中共有 14 种类型的 cp_info 每种类型的结构都是固定的
	![[截屏2023-08-04 10.17.00.png|550]]
4. **访问标志**（access_flag） 常量池结束之后的两个字节，描述了该 Class 是类还是接口，以及是否被 Public、Abstract、Final 等修饰符修饰。
5. **当前类名**（this_class） 访问标志后的两个字节，描述的是当前类的全限定名。这两个字节保存的值为常量池中的索引值，根据索引值就能在常量池中找到这个类的全限定名。
6. **父类名称**（super_class） 当前类名的后两个字节，描述父类的全限定名。这两个字节保存的值也是在常量池中的索引值，根据索引值就能在常量池中找到这个类的父类的全限定名。
7. **接口信息**（interfaces） 父类名称后的两个字节，描述这个类的接口计数器，即: 当前类或父类实现的接口数量。紧接着的 n 个字节是所有的接口名称的字符串常量在常量池的索引值。
8. **字段表**（field_table） 字段表用于描述类和接口中声明的变量，包含类级别的变量以及实例变量，但是不包含方法内部声明的 局部变量。字段表也分为两部分，第一部分是两个字节，描述字段个数，第二部分是每个字段的详细信息 field_info。
9. **方法表**（method_table） 字段表结束后为方法表，方法表也是由两部分组成，第一部分为两个字节描述方法的个数，第二个部分为每个方法的详细信息。方法的详细信息包括：方法的访问标志、方法名、方法的描述符以及方法的属性
![[截屏2023-08-04 10.21.58.png|600]]
![[截屏2023-08-04 10.21.45.png|675]]

10. **附加属性表**（additional_attribute_table） 字节码的最后一部分，存放了在文件中类或接口所定义的属性的基本信息。

## 为什么“编译”和“解释”并存

![[截屏2023-08-04 13.54.22.png]]
**Java即时编译器原理及解析**

[[https://tech.meituan.com/2020/10/22/java-jit-practice-in-meituan.html]]

这是因为 Java 语言既具有编译型语言的特征，也具有解释型语言的特征。因为 Java 程序要经过**先编译，后解释**两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（.class 文件），这种字节码必须由 Java 解释器来解释执行。

## 为什么不全部使用AOT(Ahead Of Time Copilation)
	在程序被执行前就将其编译成机器码，属于静态编译


AOT 更适合当下的云原生场景，对微服务架构的支持也比较友好。除此之外，AOT 编译无法支持 Java 的一些动态特性，如反射、动态代理、动态加载、JNI（Java Native Interface）等。

需要使用JIT即使编译器去支持Java动态特性

## Java和C++区别

Java 不提供指针来直接访问内存，程序内存更加安全
Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。
Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存。
C ++同时支持方法重载和操作符重载，但是 Java 只支持方法重载（操作符重载增加了复杂性，这与 Java 最初的设计思想不符）

# 基本语法

## 注释格式

单行，多行，文档
可读性好的代码比注释更重要

## 标识符和关键字区别

在我们编写程序的时候，需要大量地为程序、类、变量、方法等取名字，于是就有了 标识符 。简单来说， 标识符就是一个名字 。有一些标识符，Java 语言已经赋予了其特殊的含义，只能用于特定的地方，这些特殊的标识符就是 关键字 。简单来说，关键字是被赋予特殊含义的标识符 。

## 自增自减运算符

++ 和 -- 运算符可以放在变量之前，也可以放在变量之后，当运算符放在变量之前时(前缀)，先自增/减，再赋值；当运算符放在变量之后时(后缀)，先赋值，再自增/减。例如，当 b = ++a 时，先自增（自己增加 1），再赋值（赋值给 b）；当 b = a++ 时，先赋值(赋值给 b)，再自增（自己增加 1）。也就是，++a 输出的是 a+1 的值，a++输出的是 a 值。用一句口诀就是：“符号在前就先加/减，符号在后就后加/减”。

## 移位运算符

![[截屏2023-08-04 14.10.07.png|800]]

### 如果所移位数超过类型所占位数

取余之后再移动

## continue， break，return的区别 

![[截屏2023-08-04 14.13.50.png|825]]

# 基本数据类型

## 几种基本数据类型

![[截屏2023-08-07 09.11.15.png|750]]

0x --- 16进制
0b ---- 2进制
常使用double 而不使用float

### 特殊浮点值

Double.POSITIVE_INFINITY  正无穷
Double.NEGATIVE_INFINITY 负无穷
Double.NaN 不是一个数字。Double.isNaN()检测是不是数字

### char

char类型的值可以表示为十六进制值，其范围从 \\u0000 到 \\uffff 例如 \\u2122 表示注册符号 ( ), \\u03C0 表示希腊字母 pai
	可以将转译序列写入程序


### 不建议同一行声明多个变量

### 各种数据类型本身特性决定它的作用

#### byte short 常用于大型数组中代替int 节省空间

不随硬件架构的变化而变化
使用long 要使用L做结尾

## 基本类型和包装类型区别

1. 用途：除了定义一些常量和局部变量之外，我们在其他地方比如 *方法参数、对象属性* 中很少会使用基本类型来定义变量。并且，包装类型可用于泛型，而基本类型不可以。
2. 存储方式：基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 static 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中
3. 默认值：成员变量包装类型不赋值就是 null ，而基本类型有默认值且不是 null
4. 对于基本数据类型来说，== 比较的是值。对于包装数据类型来说，== 比较的是对象的内存地址。所有整型包装类对象之间值的比较，全部使用 equals() 方法。

## 为什么说几乎所有对象都存在于堆中

这是因为 HotSpot 虚拟机引入了 JIT 优化之后，会对对象进行逃逸分析，如果发现某一个对象并没有逃逸到方法外部，那么就可能通过标量替换来实现栈上分配，而避免堆上分配内存

## 包装类型的缓存机制

Byte,Short,Integer,Long 这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据，Character 创建了数值在 [0,127] 范围的缓存数据，Boolean 直接返回 True or False。

当通过自动装箱机制创建包装类对象时，首先会判断数值是否在-128—-127的范围内，如果满足条件，则会从缓存（常量池）中寻找指定数值，若找到缓存，则不会新建对象，只是指向指定数值对应的包装类对象，否则，新建对象。

Float Double 两种类型没有实现缓存

在缓存值范围内的对象可以直接在常量池中取出，不用创建新的对象；
当需要频繁的使用同一对象的时候，如果有缓存，则可以避免重复创建同一对象，节省空间开销和时间消耗，提升了性能。

**原理**
当包装类加载时，该包装类中的内部类xxCache会初始化一个包装类类型数组，最小值（固定值）为-128,而最大值（默认值）为127【可修改】，这个长度的缓存值放在方法区的常量池中，是所有线程共享的。
```java
 private static class IntegerCache {
        static final int low = -128;
        static final int high;
        static final Integer cache[];//声明为final，所以缓存的对象会被放入常量池中；声明为statci，所以是在类加载的时候就创建好了
        //创建-128～127的值的包装类对象
        static {
            // high value may be configured by property
            int h = 127;
            String integerCacheHighPropValue =
                sun.misc.VM.getSavedProperty("java.lang.Integer.IntegerCache.high");
            if (integerCacheHighPropValue != null) {
                try {
                    int i = parseInt(integerCacheHighPropValue);
                    i = Math.max(i, 127);
                    // Maximum array size is Integer.MAX_VALUE
                    h = Math.min(i, Integer.MAX_VALUE - (-low) -1);
                } catch( NumberFormatException nfe) {
                    // If the property cannot be parsed into an int, ignore it.
                }
            }
            high = h;

            cache = new Integer[(high - low) + 1];
            int j = low;
            for(int k = 0; k < cache.length; k++)
                cache[k] = new Integer(j++);

            // range [-128, 127] must be interned (JLS7 5.1.7)
            assert IntegerCache.high >= 127;
        }

        private IntegerCache() {}
    }
```

当发生自动包装的时候，调用valueOf方法，对需要包装的基本类型的值进行判断，如果在缓存值的范围内，则返回缓存的对象，否则创建一个新的对象返回。
```java
public static Integer valueOf(int i) {
    //其中low是最小值，high是最大值
   if (i >= IntegerCache.low && i <=IntegerCache.high)
   {
       //返回的是缓存中的对象
       return IntegerCache.cache[i + (-IntegerCache.low)];
   }

   return new Integer(i);
} 
```

## 自动装箱，拆箱

Integer i = 10;  //装箱
int n = i;   //拆箱

从字节码中，我们发现装箱其实就是调用了 包装类的valueOf()方法，拆箱其实就是调用了 xxxValue()方法。

尽量避免不必要的拆箱装箱操作

## 浮点数计算精度丢失

计算机保存一个数时，宽度有限，无限循环的小数在存储过程中会被截断，小数精度发生损失

### 解决方法

BigDecimal 可以实现对浮点数的运算，不会造成精度丢失。通常情况下，大部分需要浮点数精确运算结果的业务场景（比如涉及到钱的场景）都是通过 BigDecimal 来做的。

## 超过long的数字如何表示

BigInteger 内部使用 int[] 数组来存储任意大小的整形数据。

相对于常规整数类型的运算来说，BigInteger 运算的效率会相对较低。

# 变量

## 成员变量和局部变量的区别

1. 语法形式：从语法形式上看，成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 public,private,static 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰。
2. 存储方式：从变量在内存中的存储方式来看，如果成员变量是使用 static 修饰的，那么这个成员变量是属于类的，如果没有使用 static 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。
3. 生存时间：从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动生成，随着方法的调用结束而消亡。
4. 默认值：从变量是否有默认值来看，成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值（一种情况例外:被 final 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。

## 静态变量

静态变量也就是被 static 关键字修饰的变量。它可以被类的所有实例共享，无论一个类创建了多少个对象，它们都共享同一份静态变量。也就是说，静态变量只会被分配一次内存，即使创建多个对象，这样可以节省内存。

**通常被final修饰为常量**

## 字符型和字符串类型

![[截屏2023-08-07 09.44.07.png|750]]

# 常量
	使用final 定义常量

只能被赋值一次，被赋值后不可修改

# 运算符

## strictfp

在 main 方法中的所有指令都将使用严格的浮点计算。 如果将一个类标记为 strictfp, 这个类中的所有方法都要使用严格的浮点计算。
# 方法

## 静态方法为什么不能调用非静态成员

![[截屏2023-08-07 09.46.47.png|600]]

## 静态方法和实例方法的不同

1. 调用方式：一般通过类直接调用静态方法，通过对象调用实例方法
2. 访问类成员是否存在限制：静态方法只能调用静态成员，实例方法没有限制

## 重载和重写的区别

### 重载

同一个类中，方法名相同，其他可以不同

### 重写

发生在运行期，子类对父类允许访问的方法的实现过程的重新编写

![[截屏2023-08-07 09.52.36.png|750]]
![[截屏2023-08-07 09.53.58.png|850]]


## 可变长参数
	Java5开始

只能作为函数的最后一个参数，前面也可以没有任何参数

方法重载时，优先匹配参数固定的方法

可变参数编译之后成为一个数组

# 面向对象

## 性能

**需要指定场景，否则不能简单说明面向对象性能比面向过程性能高**

## 对象创建

![[截屏2023-08-09 17.05.16.png]]
### 对象相等和引用相等的区别

对象：内存中存放的内容是否相等
引用：指向的内存地址是否相等


## 构造方法

### 没有声明构造方法

![[截屏2023-08-09 17.08.24.png]]
### 构造方法种类
	构造方法可以被重载，不能被重写

![[截屏2023-08-09 17.10.11.png]]
## 面向对象特征

### 封装

提供被外界访问的方法对属性进行操作

### 继承

![[截屏2023-08-09 17.11.55.png]]
### 多态

具体表现为父类的引用只想子类的实例

![[截屏2023-08-09 17.13.27.png]]
### 接口和抽象类

#### 共同点

![[截屏2023-08-09 17.14.22.png]]
#### 区别

![[截屏2023-08-09 17.14.50.png]]

## 深拷贝浅拷贝

### 深拷贝

完全复制对象，包括对象包含的内部对象

### 浅拷贝

在堆上创建新对象，如果原对象的对象内部属性为引用类型，复制内部对象的引用地址，原对象和拷贝对象共用一个内部对象


![[截屏2023-08-09 17.33.26.png]]

## Object 

### Object 类常见方法

### == 和 equals的区别

![[截屏2023-08-09 17.34.39.png]]

## hashcode
	获取哈希码，确定该对象在哈希表中的索引位置

hashCode和equals两个方法都是用于比较两个对象是否相等
相同哈希值，使用equals方法进行比较
碰撞

![[截屏2023-08-10 10.11.09.png]]
### 重写equals方法时必须重写hashcode方法

equals判断两个对象相等，hashcode也要相等
两个对象哈希值相等，不一定相等

## String

### String，StringBuffer，StringBuilder

![[截屏2023-08-10 10.15.05.png]]

#### 线程安全性

String 常量，线程安全
StringBuffer加锁，线程安全
StringBuilder 没加同步锁，非线程安全

![[截屏2023-08-10 10.15.42.png]]

#### 性能

![[截屏2023-08-10 10.17.32.png]]
#### 使用总结
1. 少量操作，使用String
2. 单线程操作字符串缓冲区：StringBuilder
3. 多线程：StringBuffer

### String不可变的原因

![[截屏2023-08-10 10.19.37.png]]

#### 改为使用byte存储字符串

![[截屏2023-08-10 10.20.31.png]]

### 字符串拼接

重载过的+ 和+=运算符

对应的操作实际上是通过调用**StringBuilder** 中的append方法实现的，而后调用toString方法得到String对象

#### 循环中使用

在循环中由于编译器不会创建单个的StringBuilder进行复用，会导致创建过多的StringBuilder对象

![[截屏2023-08-10 10.25.10.png]]

#### 问题解决

![[截屏2023-08-10 10.25.41.png]]

### String中的equals和Object中的equals区别

String中的equals方法被重写过，比较的是String字符串的值是否相等，Object的equals方法是比较对象的内存地址

### 字符串常量池
	提升性能，减少内存消耗针对字符串专门开辟区域，避免字符串的重复创建

### 字符串创建

字符串常量池不存在要创建对象的引用，先在常量池中创建，再再堆空间中创建
常量池中存在，则只会在堆中创建一个字符串对象

### intern方法作用
	本地方法，作用是将指定的字符串的对象引用保存在字符串常量池中

![[截屏2023-08-10 10.34.10.png]]

![[截屏2023-08-10 10.36.20.png]]

### String类型变量和常量拼接运算

![[截屏2023-08-10 10.39.11.png]]

#### 常量折叠

![[截屏2023-08-10 10.40.48.png]]
![[截屏2023-08-10 10.41.19.png]]
final修饰过的String会被当作编译器当作常量来处理，编译器在程序编译期就可以确定其值，效果相当于访问常量

# 异常

	异常类层次结构

![[截屏2023-08-10 10.43.56.png]]

## Exception和Error

![[截屏2023-08-10 10.45.42.png]]
### Checked 和 unchecked 异常

![[截屏2023-08-10 10.47.54.png]]

## Throwble 常用方法

![[截屏2023-08-10 10.48.52.png]]
![[截屏2023-08-10 10.50.01 1.png]]

## finally 中代码不执行的情况

1. 虚拟机被终止运行
2. 程序所在线程死亡
3. 关闭CPU

## 使用 try-with-resource 代替 try-catch-finally

![[截屏2023-08-10 10.57.04.png]]

![[截屏2023-08-10 10.58.34.png]]

### 需要注意

1. 不要把异常定义为静态变量，手动new
2. 抛出信息有意义
3. 更加具体的子类异常
4. 日志打印后不抛出异常

# 泛型
	使用泛型，增强代码可读性和稳定性
	通过泛型参数可以指定传入的对象类型

## 使用方法

### 泛型类

```java 
//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型
//在实例化泛型类时，必须指定T的具体类型
public class Generic<T>{

    private T key;

    public Generic(T key) {
        this.key = key;
    }

    public T getKey(){
        return key;
    }
}

Generic<Integer> genericInteger = new Generic<Integer>(123456);
```

### 泛型接口

```java
public interface Generator<T> {
    public T method();
}

//实现泛型接口，不指定类型
class GeneratorImpl<T> implements Generator<T>{
    @Override
    public T method() {
        return null;
    }
}

//指定类型
class GeneratorImpl<T> implements Generator<String>{
    @Override
    public String method() {
        return "hello";
    }
}
```

### 泛型方法

```java
public static < E > void printArray( E[] inputArray )
   {
         for ( E element : inputArray ){
            System.out.printf( "%s ", element );
         }
         System.out.println();
    }

// 创建不同类型数组：Integer, Double 和 Character
Integer[] intArray = { 1, 2, 3 };
String[] stringArray = { "Hello", "World" };
printArray( intArray  );
printArray( stringArray  );

```

### 使用场景
1. 自定义接口通用返回结果CommonResult< T > ，通过T 可根据具体的返回类型动态指定结果的数据
2. 定义Excel 处理类 ExcelUtil < T > 用于动态指定Excel导出的数据类型
3. 构建集合工具类，参考Collections 中的 sort binarySearch

# 反射机制

通过反射可以获取任意类的所有属性和方法并调用

使代码更加灵活

可以无视泛型参数的安全检查，性能稍差

## 应用场景

### 动态代理

### 注解

基于反射分析类，获取类/属性/方法/参数上的注释

## 注解
	特殊的注释，主要用于修饰类，方法或者变量，提供信息使程序在编译或者运行时使用

### 解析方法
1. 编译期直接扫描
2. 运行期通过反射处理

# SPI
	Server Provider Interface
	将服务接口和具体服务实现分离，将服务调用方和服务实现者解耦，提升程序的扩展性，可维护性。修改或者替换服务实现并不需要修改调用方

框架使用SPI进行实现

## 和API 区别

![[截屏2023-08-18 09.55.26.png]]

![[截屏2023-08-18 09.57.00.png]]

### 优缺点
	提高接口设计的灵活性

1. 需要遍历加载所有的实现类，不能做到按需加载，效率比较低
2. 多个ServiceLoader同时load时，会有并发问题

# 序列化和反序列化
	持久化Java对象，将对象存在文件中，或者在网络传输Java对象

	
	![[截屏2023-08-18 10.00.42.png]]

Java：序列化是对象也就是实例化的类
C++：结构体定义的是数据结构类型，class对应的是对象类型

## 常见应用场景

1. 对象网络传输（远程方法调用RPC）之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化
2. 对象存储到文件需要序列化，读取出需要反序列化
3. 对象存储到数据库需要序列化，从缓存数据库中读取需要反序列化
4. 对象存储到内存需要序列化，从内存读取需要反序列化

## 序列化协议对应于TCP/IP模型
	应用层

1. 应用层
2. 传输层
3. 网络层
4. 网络接口层

![[截屏2023-08-18 10.17.46.png]]

## 常见序列化协议

JDK 自带的序列化方式一般不会用 ，因为序列化效率低并且存在安全问题。比较常用的序列化协议有 Hessian、Kryo、Protobuf、ProtoStuff，这些都是基于二进制的序列化协议。像 JSON 和 XML 这种属于文本类序列化方式。虽然可读性比较好，但是性能较差，一般不会选择

### JDK 自带的序列化方式
	实现Serializable 接口

#### serialVersionUID 作用

序列化号 serialVersionUID 属于版本控制的作用。反序列化时，会检查 serialVersionUID 是否和当前类的 serialVersionUID 一致。如果 serialVersionUID 不一致则会抛出 InvalidClassException 异常。强烈推荐每个序列化类都手动指定其 serialVersionUID，如果不手动指定，那么编译器会动态生成默认的 serialVersionUID。

#### serialVersionUID 被static 修饰后怎么被序列化

修饰的变量是静态变量，位于方法区，本身是不会被序列化的。 static 变量是属于类的而不是对象。你反序列之后，static 变量的值就像是默认赋予给了对象一样，看着就像是 static 变量被序列化，实际只是假象罢了。
只是用来被JVM识别，并没有被序列化

#### 不想进行序列化的字段
	使用transient修饰

阻止实例中用此关键字修饰的变量序列化，当对象被反序列化时，被其修饰的变量值不会被持久化和恢复

**注意事项**
1. 只能修饰变量，不能修饰类和方法
2. 其修饰的变量，在反序列化后变量将会被设为默认值
3. static变量无论是否有transient修饰，均不会被序列化

### 不使用JDK自带的序列化方法的原因

![[截屏2023-08-18 11.09.04.png|675]]

### Kryo
Kryo 是一个高性能的序列化/反序列化工具，由于其变长存储特性并使用了字节码生成机制，拥有较高的运行速度和较小的字节码体积。

### Protobuf
Protobuf 出自于 Google，性能还比较优秀，也支持多种语言，同时还是跨平台的。就是在使用中过于繁琐，因为你需要自己定义 IDL 文件和生成对应的序列化代码。这样虽然不灵活，但是，另一方面导致 protobuf 没有序列化漏洞的风险。

### ProtoStuff
更多功能和更简易用法

### Hessian
是一个轻量级的，自定义描述的二进制 RPC 协议。Hessian 是一个比较老的序列化实现了，并且同样也是跨语言的。

Kryo 是专门针对 Java 语言序列化方式并且性能非常好，如果你的应用是专门针对 Java 语言的话可以考虑使用，并且 Dubbo 官网的一篇文章中提到说推荐使用 Kryo 作为生产环境的序列化方式。

# JavaIO
	IO流作用于Java中数据的输入和输出

派生于4个抽象基类
InputStream/Reader 
OutputStream/Writer

以上前者字节，后者字符

## 为什么区分字节和字符

1. 字符流由Java虚拟机将字节转换得到，过程耗时、、
2. 不知道编码类型，使用字节流容易出现乱码问题

## IO模型详解


# 语法糖
	方便程序员开发程序设计的特殊语法，简洁易阅读

**JVM无法识别语法糖**，需要调用desugar() 方法进行解糖

### 常见语法糖

泛型、自动拆装箱、变长参数、枚举、内部类、增强 for 循环、try-with-resources 语法、lambda 表达式等。













