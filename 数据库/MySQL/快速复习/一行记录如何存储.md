# MySQL 的数据存放在哪个文件？

	由存储引擎实现的，MySQL 支持多种存储引擎，不同的存储引擎保存的文件自然也不同。

**SHOW VARIABLES LIKE 'datadir'; **

*db.opt* ，用来存储当前数据库的默认字符集和字符校验规则。
*t_order.frm* ，t_order 的表结构会保存在这个文件。
	用来保存每个表的元数据信息的，主要包含表结构定义。
*t_order.ibd* ，t_order 的表数据会保存在这个文件。
	表数据既可以存在共享表空间文件（文件名：ibdata1）里，也可以存放在独占表空间文件（文件名：表名字.ibd）。这个行为是由参数 **innodb_file_per_table** 控制的，若设置了参数 innodb_file_per_table 为 1，则会将存储的数据、索引等信息单独存储在一个独占表空间，从 MySQL 5.6.6 版本开始，它的默认值就是 1 了，因此从这个版本之后， MySQL 中每一张表的数据都存放在一个独立的 .ibd 文件。

## 表空间文件结构
	表空间由段（segment）、区（extent）、页（page）、行（row）组成

![[Pasted image 20240326182746.png]]

## 行

### 行格式
	一条记录的存储结构
1. Redundant 是很古老的行格式了， MySQL 5.0 版本之前用的行格式，现在基本没人用了。
2. 由于 Redundant 不是一种紧凑的行格式，所以 MySQL 5.0 之后引入了 Compact 行记录存储方式，Compact 是一种紧凑的行格式，设计的初衷就是为了让一个数据页中可以存放更多的行记录，从 MySQL 5.1 版本之后，行格式默认设置成 Compact。
3. Dynamic 和 Compressed 两个都是紧凑的行格式，它们的行格式都和 Compact 差不多，因为都是基于 Compact 改进一点东西。从 MySQL5.7 版本之后，默认使用 Dynamic 行格式。

#### compact

![[Pasted image 20240326190945.png|600]]
##### 记录的额外信息
	变长字段长度列表、NULL 值列表、记录头信息

1. 变长字段长度列表：这些变长字段的真实数据占用的字节数会按照列的顺序逆序存放，NULL 是不会存放在行格式中记录的真实数据部分里的，所以「变长字段长度列表」里不需要保存值为 NULL 的变长字段的长度。

**为什么逆序存放？** （NULL值列表中的信息同样要逆序存放）
	主要是因为「记录头信息」中指向下一个记录的指针，指向的是下一条记录的「记录头信息」和「真实数据」之间的位置，这样的好处是向左读就是记录头信息，向右读就是真实数据，比较方便。
	使得位置靠前的记录的真实数据和数据对应的字段长度信息可以同时在一个 CPU Cache Line 中，这样就可以提高 CPU Cache 的命中率。

**每个数据库表的行格式都有「NULL 值列表」吗？**
当数据表没有变长字段的时候，比如全部都是 int 类型的字段，这时候表里的行格式就不会有「变长字段长度列表」了

2. NULL 值列表：NULL 值都放到记录的真实数据中会比较浪费空间，二进制位的值为1时，代表该列的值为NULL。二进制位的值为0时，代表该列的值不为NULL。NULL 值列表必须用整数个字节的位表示（1字节8位），如果使用的二进制位个数不足整数个字节，则在字节的高位补 0。

**每个数据库表的行格式都有「NULL 值列表」吗？**
当数据表的字段都定义成 NOT NULL 的时候，这时候表里的行格式就不会有 NULL 值列表了。

**「NULL 值列表」是固定 1 字节空间吗？如果这样的话，一条记录有 9 个字段值都是 NULL，这时候怎么表示？**
当一条记录有 9 个字段值都是 NULL，那么就会创建 2 字节空间的「NULL 值列表」，以此类推
3. 记录头信息：
	1. delete_mask ：标识此条数据是否被删除。从这里可以知道，我们执行 detele 删除记录的时候，并不会真正的删除记录，只是将这个记录的 delete_mask 标记为 1。
	2. next_record：下一条记录的位置。从这里可以知道，记录与记录之间是通过链表组织的。在前面我也提到了，指向的是下一条记录的「记录头信息」和「真实数据」之间的位置，这样的好处是向左读就是记录头信息，向右读就是真实数据，比较方便。
	3. record_type：表示当前记录的类型，0表示普通记录，1表示B+树非叶子节点记录，2表示最小记录，3表示最大记录

##### 记录的真实数据
	除了我们定义的字段，还有三个隐藏字段，分别为：row_id、trx_id、roll_pointer

1. row_id ：如果我们建表的时候指定了主键或者唯一约束列，那么就没有 row_id 隐藏字段了。如果既没有指定主键，又没有唯一约束，那么 InnoDB 就会为记录添加 row_id 隐藏字段。row_id不是必需的，占用 6 个字节。
2. trx_id：事务id，表示这个数据是由哪个事务生成的。 trx_id是必需的，占用 6 个字节。
3. roll_pointer：这条记录上一个版本的指针。roll_pointer 是必需的，占用 7 个字节。

## 页
	记录是按照行来存储的，但是数据库的读取并不以「行」为单位，否则一次读取只能处理一行数据，效率非常低。

InnoDB 的数据是按**页**为单位来读写的，也就是说，当需要读一条记录的时候，并不是将这个行记录从磁盘读出来，而是以页为单位，将其整体读入内存。

**默认每个页的大小为 16KB，也就是最多能保证 16KB 的连续存储空间。**
	页是 InnoDB 存储引擎磁盘管理的最小单元，意味着数据库每次读写都是以 16KB 为单位的，一次最少从磁盘中读取 16K 的内容到内存中，一次最少把内存中的 16K 内容刷新到磁盘中。

## 区（extent）
	B+ 树中每一层都是通过双向链表连接起来的，如果是以页为单位来分配存储空间，那么链表中相邻的两个页之间的物理位置并不是连续的，可能离得非常远，那么磁盘查询时就会有大量的随机I/O，随机 I/O 是非常慢的。

	让链表中相邻的页的物理位置也相邻

在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照区为单位分配。每个区的大小为 1MB，对于 16KB 的页来说，连续的 **64** 个页会被划为一个区。

## 段（segement）
	段一般分为数据段、索引段和回滚段等。

1. 索引段：存放 B + 树的非叶子节点的区的集合；
2. 数据段：存放 B + 树的叶子节点的区的集合；
3. 回滚段：存放的是回滚数据的区的集合。

# varchar(n) 中 n 最大取值
	MySQL 规定除了 TEXT、BLOBs 这种大对象类型之外，其他所有的列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过 65535 个字节。

要算 varchar(n) 最大能允许存储的字节数，还要看**数据库表的字符集，因为字符集代表着，1个字符要占用多少字节**，比如 ascii 字符集， 1 个字符占用 1 字节，那么 varchar(100) 意味着最大能允许存储 100 字节的数据。

## 单字段
	一行数据的最大字节数是 65535（不包含 TEXT、BLOBs 这种大对象类型），其中包含了 storage overhead。就是「变长字段长度列表」和 「NULL 值列表」，也就是说一行数据的最大字节数 65535，其实是包含「变长字段长度列表」和 「NULL 值列表」所占用的字节数的。

我们存储字段类型为 varchar(n) 的数据时，其实分成了三个部分来存储：
1. 真实数据
2. 真实数据占用的字节数
3. NULL 标识，如果不允许为NULL，这部分不需要

「变长字段长度列表」所占用的字节数 = 所有「变长字段长度」占用的字节数之和。

所以，我们要先知道每个变长字段的「变长字段长度」需要用多少字节表示？**具体情况**分为：

**条件一**：如果变长字段允许存储的最大字节数小于等于 255 字节，就会用 1 字节表示「变长字段长度」；
**条件二**：如果变长字段允许存储的最大字节数大于 255 字节，就会用 2 字节表示「变长字段长度」；

65535 - 1 - 2 = 65532
在 UTF-8 字符集下，一个字符最多需要三个字节，varchar(n) 的 n 最大取值就是 65532/3 = 21844。

## 多字段

如果有多个字段的话，要保证所有字段的长度 + 变长字段字节数列表所占用的字节数 + NULL值列表所占用的字节数 <= 65535。

![[Pasted image 20240326193810.png|900]]
# 行溢出后，MySQL 是怎么处理的？

发生行溢出，多的数据就会存到另外的「溢出页」中。当发生行溢出时，在**记录的真实数据处只会保存该列的一部分数据**，而 **把剩余的数据放在「溢出页」** 中，然后真实数据处用 20 字节存储指向溢出页的地址，从而可以找到剩余数据所在的页。

![[Pasted image 20240326214229.png]]

## Compressed & Dynamic 格式

这两种格式采用完全的行溢出方式，记录的真实数据处不会存储该列的一部分数据，只存储 20 个字节的指针来指向溢出页。而实际的数据都存储在溢出页中，看起来就像下面这样：

![[Pasted image 20240326214406.png]]