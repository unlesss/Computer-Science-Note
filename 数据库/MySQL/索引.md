
# 什么是索引
	书中的目录，就是充当索引的角色，方便我们快速查找书中的内容，所以索引是以空间换时间的设计思想。

**索引是数据的目录。**

![[Pasted image 20240326220818.png]]

# 索引分类

	按「数据结构」分类：B+tree索引、Hash索引、Full-text索引。
	按「物理存储」分类：聚簇索引（主键索引）、二级索引（辅助索引）。
	按「字段特性」分类：主键索引、唯一索引、普通索引、前缀索引。
	按「字段个数」分类：单列索引、联合索引。

## 按数据结构分类
	B+Tree 索引、HASH 索引、Full-Text 索引

![[Pasted image 20240326220942.png]]

创建表时，InnoDB 存储引擎会根据不同的场景选择不同的列作为索引：
1. 如果有主键，默认会使用主键作为聚簇索引的索引键（key）；
2. 如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键（key）；
3. 在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id 列作为聚簇索引的索引键（key）；
其它索引都属于辅助索引（Secondary Index），也被称为二级索引或非聚簇索引。创建的主键索引和二级索引默认使用的是 B+Tree 索引。
### B+ 树索引
	按主键顺序存放


![[Pasted image 20240326221408.png]]
	叶子节点之间是双向链表

B+Tree 相比于 B 树和二叉树来说，最大的优势在于查询效率很高，因为即使在数据量很大的情况，查询一个数据的磁盘 I/O 依然维持在 3-4次。

	通过二级索引查询商品数据
1. 主键索引的 B+Tree 的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里；
2. 二级索引的 B+Tree 的叶子节点存放的是主键值，而不是实际数据。

主键索引的 B+Tree 的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里；
二级索引的 B+Tree 的叶子节点存放的是主键值，而不是实际数据。

#### 覆盖索引

**查询的数据是能在二级索引的 B+Tree 的叶子节点里查询到，这时就不用再查主键索引查**：

select id from product where product_no = '0002';（id 为主键）

**在二级索引的 B+Tree 就能查询到结果的过程就叫作「覆盖索引」，也就是只需要查一个 B+Tree 就能找到数据。**

### 为什么使用B+树作为索引数据结构

1. B+Tree vs B Tree

	B+Tree 只在叶子节点存储数据，而 B 树 的非叶子节点也要存储数据，所以 B+Tree 的单个节点的数据量更小，在相同的磁盘 I/O 次数下，就能查询更多的节点。

	另外，B+Tree 叶子节点采用的是双链表连接，适合 MySQL 中常见的基于范围的顺序查找，而 B 树无法做到这一点。
2. B+Tree vs 二叉树
	对于有 N 个叶子节点的 B+Tree，其搜索复杂度为**O(logdN)**，其中 d 表示节点允许的最大子节点个数为 d 个。

	在实际的应用当中， d 值是大于100的，这样就保证了，即使数据达到千万级别时，B+Tree 的高度依然维持在 3~4 层左右，也就是说一次数据查询操作只需要做 3~4 次的磁盘 I/O 操作就能查询到目标数据。

	而二叉树的每个父节点的儿子节点个数只能是 2 个，意味着其搜索复杂度为 **O(logN)**，这已经比 B+Tree 高出不少，因此二叉树检索到目标数据所经历的磁盘 I/O 次数要更多。
3. B+Tree vs Hash
	Hash 在做等值查询的时候效率很高，搜索复杂度为 O(1)。

	但是 Hash 表不适合做范围查询，它更适合做等值的查询，这也是 B+Tree 索引要比 Hash 表索引有着更广泛的适用场景的原因。

## 按照物理存储分类
	聚簇索引（主键索引）、二级索引（辅助索引）。


## 按照字段特性
	主键索引、唯一索引、普通索引、前缀索引

### 主键索引

建立在主键字段上的索引，通常在创建表的时候一起创建，一张表最多只有一个主键索引，索引列的值不允许有空值。

```sql
CREATE TABLE table_name  (
  ....
  PRIMARY KEY (index_column_1) USING BTREE
);
```
### 唯一索引

唯一索引建立在 UNIQUE 字段上的索引，一张表可以有多个唯一索引，索引列的值必须唯一，但是允许有空值。

```sql
CREATE TABLE table_name  (
  ....
  UNIQUE KEY(index_column_1,index_column_2,...) 
);
```

建表后，如果要创建唯一索引，可以使用这面这条命令：
```sql
CREATE UNIQUE INDEX index_name
ON table_name(index_column_1,index_column_2,...); 
```

### 普通索引

既不要求字段为主键，也不要求字段为 UNIQUE。

```sql
CREATE TABLE table_name  (
  ....
  INDEX(index_column_1,index_column_2,...) 
);



CREATE INDEX index_name
ON table_name(index_column_1,index_column_2,...);

```

### 前缀索引

对字符类型字段的前几个字符建立的索引，而不是在整个字段上建立的索引，前缀索引可以建立在字段类型为 char、 varchar、binary、varbinary 的列上。

```sql
CREATE TABLE table_name(
    column_list,
    INDEX(column_name(length))
); 


CREATE INDEX index_name
ON table_name(column_name(length)); 

```

## 按字段个数分类
	单列索引、联合索引（复合索引）

建立在单列上的索引称为单列索引，比如主键索引；
建立在多列上的索引称为联合索引；

