
# 如何切分

## 水平切分

### 水平分表

	表结构不变，单表数据切分成多表

结果：每个表结构不同，数据相同，所有表并集为全量数据

![[Pasted image 20240408202343.png]]

### 水平分库
	表水平切分后分到不同的数据库，使得每个库有相同的表，表中数据不同，水平分库一般伴随水平分表

![[Pasted image 20240408202534.png]]


## 垂直切分

### 垂直分表
	存在一张表中的字段切分到多张表

结果：每张表的结构不同，数据不同，并集是原表的字段

![[Pasted image 20240408203333.png]]

### 垂直分库
	单个库中的表分到多个库，每个库包含的表不同

![[Pasted image 20240408203416.png]]

## 混合切分
	组合

![[Pasted image 20240408204632.png]]




# 分库分表的原因

## 场景

### 单库出现瓶颈

1. 数据库服务器磁盘空间不足，但是无法扩容，导致写数据异常；
2. 数据库服务器 CPU 压力过大，无法升配，导致读写性能较慢；
3. 数据库服务器内存不足，无法扩容，导致读写性能瓶颈；
4. 数据库服务器网络带宽不足，无法升配，导致读写性能瓶颈；
5. 数据库服务器连接数过多，无法升配，导致客户端连接等待/超时；

### 单表出现瓶颈


### 单表出现瓶颈

### 微服务化
	按照不同的域来划分管理数据库，对数据库进行物理和权限隔离，从而进行分库分表

![[Pasted image 20240408212522.png]]

# 切分策略

## Range 范围
	Range 范围是指按某个字段的数据区间来进行切分。

![[Pasted image 20240408212602.png]]


**优点**

方便扩容，每次数据量达到 range值就新加一张表，可以通过代码实现自动化扩容；

**缺点**

存在写偏移，可能有热点问题； 比如用户注册场景：user表，因为新注册的用户数据都是写新表，通常来说新用户的活跃度高，所以读写流量全部集中在最新的 user表，因此，**新表可能存在热点问题。**

## hash 切分
	分表键 key 进行一定的运算（通常有取余、取模运算，比如：key % m，key / m，hash(key)/m 等等），通过运算结果来决定路由的库和表


**优点**

数据分片比较均匀，大大降低热点问题；

**缺点**

hash 算法选择不合理，后期扩容可能需要迁移数据；
数据被切分到不同的库和表中，可能存在跨节点查询和分页等问题；

## 映射表
	映射表其实是 Range范围 和 hash切分的混合模式，将分表键和数据库的映射关系记录在一个单独的表（表的形式可以是 数据库表，文件或者配置中心）

**优点**

可以灵活设置路由规则；

**缺点**

方案比较复杂；
映射表可能也会随着业务量的增大，同样需要分库分表，带来更多的问题；

![[Pasted image 20240408220643.png]]

# 产生的问题

	调试和维护难度
	分布式
	分布式事务
	跨库关联/分页/排序


## 定位和维护难度
	需要先根据 key找到库和表，这样在一定意义上增加了开发人员定位问题的难度

### 分布式ID
	UUID、号段模式（数据库生成全局ID）、雪花算法。
#### UUID

UUID**优点**：

性能非常高，本地生成，没有网络消耗；

UUID**缺点**：

1. 不易于存储：UUID太长，16字节128位，通常以36长度的字符串表示，很多场景不适用;
2. 信息不安全：基于MAC地址生成UUID的算法可能会造成MAC地址泄露，这个漏洞曾被用于寻找梅丽莎病毒的制作者位置;
3. ID作为主键时在特定的环境会存在一些问题，比如做DB主键的场景下，UUID就非常不适用。

#### 号段模式

号段模式**优点**：

1. 可以每次获取一个ID，也可以每次获取一批ID；
简单，利用现有数据库系统的功能实现；
2. ID单调自增，可以实现对ID要求特殊的业务；

号段模式**缺点**：

强依赖发号DB的性能，可能有单点问题；


#### 雪花算法

雪花算法**优点**：

1. 毫秒数在高位，自增序列在低位，整个ID都是趋势递增的。
2. 不依赖数据库等第三方系统，以服务的方式部署，稳定性更高，生成ID的性能也是非常高的。
3. 可以根据自身业务特性分配bit位，非常灵活。

雪花算法**缺点**：

强依赖机器时钟，如果机器时钟回拨，会导致重复或者服务不可用，不过发生的概率比较小；

### 分布式事务
	单库单表可以直接使用本地事务来保障数据的正确性，分库分表之后可能就需要引入分布式事务的问题

解决方案：业务划分的时候规避分布式事务；使用专业的的分布式框架，比如阿里开源的 Seata；


### 跨库关联，分页，排序

单库单表可以直接使用 MySQL limit 特性实现分页，分库分表后，可能会出现分页问题，解决方案有三种：

1. 选择合适的分表字段，规避绝大部分高频查询场景出现跨库；
2. 使用专业的分布式框架，比如开源框架：ElasticSearch；
3. 业务代码中分别查询，然后组装数据；

## 分库分表工具




